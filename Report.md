MapReduce作业报告 计25 矣晓沅 2012011364

这次作业略坑，花了好几天只是在本地跑了起来，还无法上传。写一写本地跑起来的心得，也算是对MapReduce 有了一些理解。

具体本地MR配环境御膳房的文档里讲得比较清楚就不再赘述了。本地的数据在工程目录下的warehouse/loacl里，两个文件夹，一个是输入数据的文件及格式，一个是输出数据的文件及格式。两个文件夹我这里分别命名为simcompute_in和simcompute_out.数据格式在两个文件夹的_schema_中设置。我按照御膳房里真实数据的格式设置如下：

输入数据：
    project=local
    table=simcompute_in
    columns=sid:BIGINT,uid:BIGINT,action:STRING
    partitions=dt:STRING

输出数据：

    project=local
    table=simcompute_out
    columns=sid:BIGINT,simid:BIGINT,simvalue:DOUBLE
    partitions=dt:STRING

输入数据即是作业说明里的，每条数据是一个三元组< merchant id; user id; action >,我的数据数据是一个三元组，即<某个商家的id；和该商家相似的商家id；余弦距离>。注意这里定义的是整个工程输入和最终输出数据的格式。
MapReduce的思路大致就是用Map先做映射，把输入的数据映射成一个<Key,Value>对，再把这些Value对经过Combine(Combine的具体作用可以自己定)，然后传到Reducer，Reducer做处理后输出。也就是Map的输入是整个工程的输入，格式是在刚刚那个_schema_里设定。Map的输出是一个<key,value>对，combine的输入输出，reducer的输入都是这个键值对的格式。键值对的设置在base.mapred.xml里，我的设置如下：

    <mapOutputKey>i:bigint</mapOutputKey>
    <mapOutputValue>which:string,k:bigint,j:bigint,val:bigint</mapOutputValue>

再来看我们的问题。设商家数为M，用户数为N。按照作业文档，每个商家用一个4*N的向量来表示。所有商家的数据就是一个M*(4*N)的矩阵，设这个矩阵为A。我们要求商家之间两两的相似度，即余弦距离，实际上可以转换为求一个矩阵乘法，即A*A^T=C的问题。计算A乘A转置即可得到向量两两之间的内积，再除以模即是余弦距离。MapReduce要做的，是对矩阵乘法的分解，让矩阵C中，每个元素的求取(两个向量的内积)在一个reducer中做。Map输出的键值对，是按照key的值发往不同的reducer的，即key的值决定了这个键值对发往那个reducer。为了方便，将A的转置称为B。
Map阶段，从输入表获取一个三元组(即A矩阵的一个元素)，需要存储成m个<key, value>对，并且这个key互不相同；再存成m个个<key, value>对，同样的，个key也应互不相同；但用于计算同一个的cij的所有A，B元素<key, value>对的key应该都是相同的，以保证能被发到同一Reducer。

具体做法如下：

1. Map时，对每个传进来的数据，即A的元素aij，其中，seller_id即i，user_id可以对应到j，因为向量长度是4*N。这里可以把aij的全都记为1.然后生成M个<key,value>的键值对，写入context。其中，，Key=(i,k), k = 1,2,…,m，而Value中包含了矩阵的type，即是A还是A转置，还有j的值，以及实际的元素值，元素值初始为1。然后再对矩阵B的每个元素，注意B是A的转置，对每个bjk，其中j是seller_id,k是user_id的对应值。也生成M个<key,Value>.key=(i,k),i=1,2,…,m,同样，value也如上设置.

2. 如此，所有计算cik的A，B元素都会有相同的key=(i,k)。在combine时，我们需要把所有key相同且j也相同的元素进行一个累加，即统计有多少个这样的键值对，然后把Value中的val设为其数目值。

3. 所有(i,k)相同的键值对发到了同一个reducer，这些键值对即计算cij所需的所有A，B的元素。根据Value里存的j值，A向量元素a和B向量元素中哪一个对应，然后相乘累加，最后再用这些元素算出模，除一下就行。

具体可以参考如下博文：

http://blog.csdn.net/xyilu/article/details/9066973

里面讲了如何用MapReduce来做大矩阵乘法，我主要就是参考这个的。

另外，本地跑时，因为御膳房上的数据id太大，商家数为86799，用户数为9774184，而且这些id不是连续的，即矩阵的M要大于86799，N大于4*9774184。按照上述方法，计算量由矩阵规模决定，御膳房的数据本地跑不动，虽然现在能查到的数据只有5000条。石伟男大神的做法是，新建一个类，把一个个输入进来的seller_id,user_id都做hash，用HashMap存。我就直接按照御膳房数据的格式，随机生成了一个小规模的本地数据集来做测试(2000条数据，40个商家，300个用户)。

另外，作业要求排序输出与每个商家最相似的top5。按照上述方法，没有办法排序。一个办法是，可以利用pipline，在一层MapReduce后追加一个Reducer进行排序，或者用多任务，写两层MapReduce，第一层算，第二层排序。具体方法详见御膳房的opds_MapReduce文档。
但是写的时候注意到，JobLauncher.java里有如下注释：

    /**
     * Mapreduce任务的主程序。
     * 注意：此文件只供本地测试使用，所有修改不会反映到最终线上实际执行的JobLauncher。
     * 所有对mapreduce进行的配置请在main/resources/META-INF/base.mapred.xml中完成
     */

然后pipline和多任务都是在JobLaucher里配的，我和伟男大神都不知道如何在xml里配，也找不相关说明。我的做法就是，把多个cij的计算都发到一个reducer里。上述方法中，cij在一个reducer里算，现改为cik，k=1,2,..,m在一个reducer里算，算完排序输出前5。这样Reducer压力较大， 但是没有办法当时担心IDE中跑会跪(虽然现在也传不上去)
然后程序的部分输出结果向下面这个样子：

    22,29,0.13223592098145726
    22,25,0.10974589708533941
    22,23,0.10864289525102223
    22,33,0.1012220412723645
    22,31,0.08479449518438636
    23,22,0.10864289525102223
    23,30,0.09931270663228417
    23,39,0.09128709291752768
    23,19,0.07770286898858113
    23,1,0.07071067811865475
    24,17,0.08447772061910234
    24,7,0.07098727864204515
    24,26,0.07024393586862705
    24,31,0.06446025638903101
    24,38,0.06335829046432676
    25,9,0.14091341769030624
    25,22,0.10974589708533941
    25,0,0.10531568296778367
    25,19,0.10101525445522107
    25,20,0.09460945407607456

只能本地跑小规模数据了，大规模数据跑步起来，本地程序也传不上去~
